import 'utilities.eol';

context ENamedElement {
	constraint NotReservedWord {
		check {
			return not self.name.isThriftReservedWord();
		}
		message : self.name + " is a reserved word! Please call it something different!"
	}
}

context EClass {
	constraint OperationsOrFields {
		check {
			return self.eOperations.isEmpty() or self.eAttributes.isEmpty();
		}
		message : "You must have either no operations or no fields in " + self.name
	}
	/*
	constraint NoReferences {
		check {
			// lists are kind of references too
			return self.eReferences.forAll(ref | ref.isMany());
		}
		message : "There must not be any references in " + self.name
	}
	*/
}

context EClass {
	// No operations, ie., is a struct or exception
	guard : self.eOperations.isEmpty()

	constraint ValidEnumeration {
		check {
			// the number annotation is valid when it exists
			// TODO: check that they are unique! (including the ones without explicit numbers)
			return self.eOperations.forAll(annotation | annotation.hasNumberAnnotation() implies annotation.isNumberAnnotationValid());
		}
		message : "@thrift(n=...) annotations must have an integer value!"
	}
	
	constraint FieldNumbering {
		check {
			return self.eAttributes.numberAnnotationsUnique();
		}
	}
	
	constraint EitherExceptionOrStruct {
		check {
			return not (self.isUsedAsException() and self.isUsedAsStruct());
		}
		message : self.name + " is used as both an exception and a struct!"
	}
	
	critique UsedAsExceptionOrStruct {
		check {
			return self.isUsedAsException() or self.isUsedAsStruct();
		}
		message : self.name + " is not used!"
	} 
}

context EClass {
	// is a service
	guard : self.eAttributes.isEmpty() and not self.eOperations.isEmpty()

}

context EOperation {
	constraint NoNumbering {
		check {
			return not self.hasNumberAnnotation();
		}
		message : "An operation should not have a @thrift(n=...) annotation!"
	}
	
	constraint ParameterNumbering {
		check {
			return self.eParameters.numberAnnotationsUnique();
		}
		message : "All parameters should have unique numbers in " + self.name
	}
	
	constraint ExceptionNumbering {
		check {
			return self.eExceptions.numberAnnotationsUnique();
		}
		message : "All exceptions should have unique numbers in " + self.name
	}
}